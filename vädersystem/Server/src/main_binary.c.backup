#include "tcp_server.h"
#include "vader_api.h"
#include "cache.h"
#include "loggning.h"
#include "konfiguration.h"
#include "vaderprotokoll.h"
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <stdbool.h>

// Global flagga för att stoppa servern vid Ctrl+C
static volatile bool kors = true;

// Signal-hanterare för Ctrl+C
void signal_hanterare(int signal) {
    (void)signal;  // Oanvänd parameter
    LOGG_INFO("Mottog stoppSignal, stänger servern...");
    kors = false;
}

// Hantera klientförfrågan
void hantera_klient(socket_t klient_socket, const char* api_nyckel) {
    char buffer[BUFFER_STORLEK];
    ProtokollHuvud huvud;

    // Ta emot protokollhuvud
    int mottaget = recv(klient_socket, (char*)&huvud, sizeof(huvud), 0);
    if (mottaget != sizeof(huvud)) {
        LOGG_VARNING("Mottog inkomplett protokollhuvud");
        stang_socket(klient_socket);
        return;
    }

    // Kontrollera protokollversion
    if (huvud.version != PROTOKOLL_VERSION) {
        LOGG_VARNING("Felaktig protokollversion: %d (förväntat %d)",
                     huvud.version, PROTOKOLL_VERSION);

        // Skicka felmeddelande
        FelMeddelande fel;
        fel.felkod = FEL_OKÄNT;
        snprintf(fel.meddelande, sizeof(fel.meddelande),
                 "Protokollversion stöds ej");

        huvud.typ = MEDDELANDE_FEL;
        huvud.langd = hton16(sizeof(fel));
        send(klient_socket, (char*)&huvud, sizeof(huvud), 0);
        send(klient_socket, (char*)&fel, sizeof(fel), 0);
        stang_socket(klient_socket);
        return;
    }

    // Hantera meddelandetyp
    switch (huvud.typ) {
        case MEDDELANDE_HAMTA_VADER:
        case MEDDELANDE_HAMTA_PROGNOS: {
            // Ta emot väderförfrågan
            VaderForfragan forfragan;
            mottaget = recv(klient_socket, (char*)&forfragan, sizeof(forfragan), 0);
            if (mottaget != sizeof(forfragan)) {
                LOGG_VARNING("Mottog inkomplett väderförfrågan");
                break;
            }

            LOGG_INFO("Förfrågan om %s för: %s, %s",
                      (huvud.typ == MEDDELANDE_HAMTA_VADER) ? "väder" : "prognos",
                      forfragan.stad, forfragan.landskod);

            if (huvud.typ == MEDDELANDE_HAMTA_VADER) {
                VaderData vader_data;
                bool lyckades = false;

                // Försök läsa från cache först
                if (las_fran_cache(forfragan.stad, forfragan.landskod, &vader_data)) {
                    lyckades = true;
                    LOGG_INFO("Använder cachad data");
                } else {
                    // Hämta från API
                    if (hamta_aktuellt_vader(forfragan.stad, forfragan.landskod,
                                            api_nyckel, &vader_data)) {
                        lyckades = true;
                        // Spara i cache
                        skriv_till_cache(forfragan.stad, forfragan.landskod, &vader_data);
                    }
                }

                // Skicka svar
                if (lyckades) {
                    huvud.typ = MEDDELANDE_VADER_SVAR;
                    huvud.langd = hton16(sizeof(vader_data));
                    send(klient_socket, (char*)&huvud, sizeof(huvud), 0);
                    send(klient_socket, (char*)&vader_data, sizeof(vader_data), 0);
                    LOGG_INFO("Skickade väderdata till klient");
                } else {
                    // Skicka felmeddelande
                    FelMeddelande fel;
                    fel.felkod = FEL_API_FEL;
                    snprintf(fel.meddelande, sizeof(fel.meddelande),
                             "Kunde inte hämta väderdata");

                    huvud.typ = MEDDELANDE_FEL;
                    huvud.langd = hton16(sizeof(fel));
                    send(klient_socket, (char*)&huvud, sizeof(huvud), 0);
                    send(klient_socket, (char*)&fel, sizeof(fel), 0);
                    LOGG_FEL("Kunde inte hämta väderdata");
                }
            } else {
                // Prognos
                VaderPrognos prognos;
                bool lyckades = false;

                if (las_prognos_fran_cache(forfragan.stad, forfragan.landskod, &prognos)) {
                    lyckades = true;
                } else {
                    if (hamta_vader_prognos(forfragan.stad, forfragan.landskod,
                                           api_nyckel, &prognos) > 0) {
                        lyckades = true;
                        skriv_prognos_till_cache(forfragan.stad, forfragan.landskod, &prognos);
                    }
                }

                if (lyckades) {
                    huvud.typ = MEDDELANDE_VADER_SVAR;
                    huvud.langd = hton16(sizeof(prognos));
                    send(klient_socket, (char*)&huvud, sizeof(huvud), 0);
                    send(klient_socket, (char*)&prognos, sizeof(prognos), 0);
                    LOGG_INFO("Skickade prognos till klient");
                } else {
                    FelMeddelande fel;
                    fel.felkod = FEL_API_FEL;
                    snprintf(fel.meddelande, sizeof(fel.meddelande),
                             "Kunde inte hämta prognos");

                    huvud.typ = MEDDELANDE_FEL;
                    huvud.langd = hton16(sizeof(fel));
                    send(klient_socket, (char*)&huvud, sizeof(huvud), 0);
                    send(klient_socket, (char*)&fel, sizeof(fel), 0);
                }
            }
            break;
        }

        default:
            LOGG_VARNING("Okänd meddelandetyp: %d", huvud.typ);
            break;
    }

    stang_socket(klient_socket);
}

int main(int argc, char* argv[]) {
    // Kontrollera API-nyckel
    if (argc < 2) {
        fprintf(stderr, "Användning: %s <OpenWeatherMap-API-nyckel> [port] [lognivå]\n", argv[0]);
        fprintf(stderr, "Lognivå: 0=DEBUG, 1=INFO, 2=VARNING, 3=FEL (standard: 1)\n");
        return 1;
    }

    const char* api_nyckel = argv[1];
    int port = (argc > 2) ? atoi(argv[2]) : SERVER_PORT;
    LogNiva log_niva = (argc > 3) ? (LogNiva)atoi(argv[3]) : LOG_NIVA_INFO;

    // Initialisera loggning
    initiera_loggning(log_niva);
    LOGG_INFO("=== Vädersystem Server ===");
    LOGG_INFO("Startar server på port %d", port);

    // Initialisera cache
    if (!initiera_cache()) {
        LOGG_VARNING("Cache-initialisering misslyckades, fortsätter utan cache");
    }

    // Registrera signal-hanterare
    signal(SIGINT, signal_hanterare);
#ifndef _WIN32
    signal(SIGTERM, signal_hanterare);
#endif

    // Initialisera TCP-server
    TcpServer server;
    if (initiera_tcp_server(&server, port) != 0) {
        LOGG_FEL("Kunde inte starta TCP-server");
        stang_loggning();
        return 1;
    }

    LOGG_INFO("Server lyssnar på port %d. Tryck Ctrl+C för att stoppa.", port);

    // Huvudloop - acceptera och hantera klienter
    while (kors) {
        socket_t klient = acceptera_klient(&server);
        if (klient != OGILTIG_SOCKET) {
            hantera_klient(klient, api_nyckel);

            // Rensa gammal cache var 10:e klient
            static int klient_rakn are = 0;
            if (++klient_raknare % 10 == 0) {
                rensa_gammal_cache();
            }
        }

        // Kort paus för att undvika CPU-spinning
#ifdef _WIN32
        Sleep(10);  // Windows: millisekunder
#else
        usleep(10000);  // Linux: mikrosekunder (10ms)
#endif
    }

    // Stäng server
    stang_tcp_server(&server);
    LOGG_INFO("Server stoppad");
    stang_loggning();

    return 0;
}
